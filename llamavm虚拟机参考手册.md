# llamavm虚拟机参考手册

---

## （1）介绍

llamavm是一个基于lua语言设计开发的虚拟机，这里说的虚拟机不是vmware这种运行各类操作系统的软件，而是类似于jvm、.net-framework、python、JavaScript-v8等提供高级语言运行环境的基础软件。

各种语言的虚拟机实现不尽相同，差异点如下：
> （1）是否提供系统os功能？

|-|举例|优点|缺点|
|-|-|-|-|
|不支持|lua语言不提供任何os相关的功能，比如多线程、socket等，仅限c标准库支持的功能|可移植性强，在任意支持ansi c的系统上都可以编译运行，包括嵌入式设备、游戏主机、手机系统、服务器等|需要借助第三方库实现os相关的功能，不便于开发复杂系统|
|支持|java、python、.net都提供os相关功能，几乎将系统api全部封装了一遍|使用方便，不需要了解系统api|可移植性差，对于每个系统都需要定制开发一套安装包，比如.net只支持Windows系统|

> （2）编译型还是解释型？

语言可分为编译型和解释型两种，但现在已经很难分清是编译型还是解释型，甚至可以说所有语言都是解释型，差异就是cpu解释还是虚拟机解释。真正需要关心的是，生成的指令究竟是机器指令还是中间字节码指令。

c、c++、golang直接生成机器指令，lua、python、java、c#生成字节码指令，但也有可能直接生成机器指令，如各类jit版本的编译器，如luajit、HotSpot VM、JavaScript v8等。

jit版本执行性能更高，常常比原生版本快上好几倍，但由于和机器绑定，需要每个系统定制一套。

> （3）基于堆栈还是寄存器的指令？

以计算 ``` 1+2+3 ```为例，基于堆栈的处理方法是每次计算都先将数据压栈，计算完成后再弹出，指令如下：
```
push 1
push 2
push 3
add
```

基于寄存器的处理方法是获取每个数据的地址，直接计算，指令如下：
```
add 1 2 3
```

特点比较：

|类型|优点|缺点|
|-|-|-|
|基于堆栈|指令简单，每条指令只需要1个byte，故称字节码指令|指令量大，不容易优化|
|基于寄存器|指令量少，容易精简指令|实现起来比较困难，单条指令更长|

目前大部分虚拟机都是基于堆栈实现的，仅有lua5.0、Android Dalvik虚拟机基于寄存器实现。

**llamavm**是基于堆栈实现的虚拟机，因为简单。


---

## （2）语法

得益于游戏行业重度使用lua语言来实现玩法逻辑，以及OpenResty这一基于**Nginx+lua**开源项目的大量使用，说明大家还是喜欢简单易用的工具，随着技术的推进，未来编程会越来越easy，当然这是题外话。

llamavm完全基于lua语法实现，已经掌握lua语法的可以很轻松理解本节内容，有编程基础的也可以在很快掌握lua语法。

> llamavm的实现与官方lua语法有差异的地方，会有专门提示。

### （2.1）变量

#### **变量分类**

|变量类型|说明|
|-|-|
|全局变量|默认|
|局部变量|**local** 关键字修饰|
|upvalue|内部函数引用的外部函数的局部变量|

示例如下：
```python
# a 和 b 为全局变量
a = 0
b = a + 1
```

```python
# c 和 d 为局部变量
local c = 0
local d = c + 1
```

```python
function f1()
  local e = 0  # e 为局部变量
  function f2(f)  # f 为局部变量
    return e+f  # e 为外部函数 f1 的局部变量，也称upvalue
  end
end
```


#### **变量作用域**

|变量类型|说明|
|-|-|
|全局变量|在任意位置都生效，除非有**同名变量覆盖**|
|局部变量|作用域同c/c++语言的**块作用域**，离开其定义块后自动失效|
|upvalue|**llamavm尚未实现**|

示例如下：
```python
a = 0  # 全局变量
function f1()
  local b = 1  # b 仅在函数f1内部有效
  if a > 0 then  # 这里为全局 a
    local a = 1  # 定义局部变量a， 全局a 暂时失效
    b = a  # 这里为局部 a
  end
  
  b = a  # 这里又恢复为全局 a
end
```

### （2.2）运算符

运算符可分为一元运算符和二元运算符，运算符及其优先级**从高到低**如下：

|类型|运算符|描述|优先级↓|
|-|-|-|-|
|二元|and or|逻辑运算|6|
|一元|not|取反 |5|
|一元|-|负号|5|
|二元|\* /|乘、除|4|
|二元|\+ \-|加、减|3|
|二元|..|字符串拼接|2|
|二元|== ~= > < >= <=|大小比较|1|

#### **and/or运算符**
不同于多数语言的&& 和 || 运算，and/or返回的是其中**一个表达式的值**

|运算符|说明|
|-|-|
|and|返回第一个false表达式，若无则返回最后一个表达式|
|or|返回第一个true表达式，若无则返回最后一个表达式|

示例如下：
```python
a = 1 and 2 and 3  # 返回第一个false表达式，结果为3
b = 1 or 2 or 3  # 返回第一个true表达式，结果为1

# 第一步 1 and 2，返回第一个false表达式，结果为2
# 第二部 2 or 3， 返回第一个true表达式，结果为2
c = 1 and 2 or 3 
```

#### **not运算符**
相当于多数语言的 ! 取反运算符，在lua里false和nil为假，其他皆为真。

#### **..字符串拼接**
示例代码：
```python
a= "this is" .. " a project"
```

#### **比较运算符**
不相等为~=，不同于多数语言的 != 运算符。


### （2.3）控制语句

#### **语句类型**

|类型|示例|
|-|-|
|if|if a>1 then ... end|
|if/else|if a>1 then ... else ... end|
|if/elseif|if a>1 then ... elseif a>2 then ... end|
|if/elseif/else|if a>1 then ... elseif a>2 then ... else ... end|
|while|while a>1 do ... end|
|for|for i=1,10 do ... end|
|break|while a>1 do break end|
|continue|for i=1,10 do continue end|

#### **if和while**
和多数语言保持一致，while循环不要忘记增加计数器的值。

#### **for循环**
``` 
for i=1,10 do ... end
等同于
for (int i=1; i<=10; i++) { ... }
```
完全的for循环定义为：
```
for i=初始值, 上限值, 递增值 do ... end
```

 - 参数3```递增值```可以为负数，用于实现从大到小遍历。
 - 变量```i```是局部变量，仅在for循环内部生效。

#### **continue**
官方lua实现**不支持continue**关键字，并提供repeat/until语句模拟实现continue效果，这一点被广大用户所诟病。

llamavm **支持continue**语句，并且不支持repeat/until语句，这一点更符合广告用户的使用习惯。
